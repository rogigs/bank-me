/**
 * Generated by orval v7.3.0 游꽄
 * Do not edit manually.
 * Bankme
 * The BankeMe API description
 * OpenAPI spec version: 1.0
 */
import useSwr from 'swr'
import type {
  Arguments,
  Key,
  SWRConfiguration
} from 'swr'
import useSWRMutation from 'swr/mutation'
import type {
  SWRMutationConfiguration
} from 'swr/mutation'
export type UserControllerFindOneParams = {
/**
 * Par칙metros de consulta din칙micos (enviar como um objeto JSON)
 */
query?: { [key: string]: unknown };
};

export type UserControllerFindManyParams = {
/**
 * Quantidade de itens por p치gina
 */
limit: number;
/**
 * N칰mero da p치gina
 */
page: number;
};

export type AssignorControllerFindOneParams = {
/**
 * Par칙metros de consulta din칙micos (enviar como um objeto JSON)
 */
query?: { [key: string]: unknown };
};

export type AssignorControllerFindManyParams = {
/**
 * Quantidade de itens por p치gina
 */
take: number;
/**
 * N칰mero da p치gina
 */
page: number;
};

export type PayableControllerUploadFileBody = {
  file?: Blob;
};

export type PayableControllerCreateManyBody = {
  file?: Blob;
};

export type PayableControllerFindOneParams = {
/**
 * Par칙metros de consulta din칙micos (enviar como um objeto JSON)
 */
query?: { [key: string]: unknown };
};

export type PayableControllerFindManyParams = {
/**
 * Quantidade de itens por p치gina
 */
take: number;
/**
 * N칰mero da p치gina
 */
page: number;
};

export interface EmailDTO {
  message: string;
  subject: string;
  to: string;
}

export interface UserNoBaseModelDTO {
  email: string;
  password: string;
}

export interface AssignorNoBaseModelDTO {
  document: string;
  email: string;
  name: string;
  phone: string;
}

export interface PayableNoBaseModelDTO {
  assignorId: string;
  emissionDate: string;
  value: number;
}




  
  export type payableControllerCreateResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getPayableControllerCreateUrl = () => {


  return `/v1/integrations/payable`
}

export const payableControllerCreate = async (payableNoBaseModelDTO: PayableNoBaseModelDTO, options?: RequestInit): Promise<payableControllerCreateResponse> => {
  
  const res = await fetch(getPayableControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      payableNoBaseModelDTO,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getPayableControllerCreateMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: PayableNoBaseModelDTO }): Promise<payableControllerCreateResponse> => {
    return payableControllerCreate(arg, options);
  }
}
export const getPayableControllerCreateMutationKey = () => [`/v1/integrations/payable`] as const;

export type PayableControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof payableControllerCreate>>>
export type PayableControllerCreateMutationError = Promise<unknown>

export const usePayableControllerCreate = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof payableControllerCreate>>, TError, Key, PayableNoBaseModelDTO, Awaited<ReturnType<typeof payableControllerCreate>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPayableControllerCreateMutationKey();
  const swrFn = getPayableControllerCreateMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type payableControllerFindManyResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getPayableControllerFindManyUrl = (params: PayableControllerFindManyParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `/v1/integrations/payable?${normalizedParams.toString()}` : `/v1/integrations/payable`
}

export const payableControllerFindMany = async (params: PayableControllerFindManyParams, options?: RequestInit): Promise<payableControllerFindManyResponse> => {
  
  const res = await fetch(getPayableControllerFindManyUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getPayableControllerFindManyKey = (params: PayableControllerFindManyParams,) => [`/v1/integrations/payable`, ...(params ? [params]: [])] as const;

export type PayableControllerFindManyQueryResult = NonNullable<Awaited<ReturnType<typeof payableControllerFindMany>>>
export type PayableControllerFindManyQueryError = Promise<unknown>

export const usePayableControllerFindMany = <TError = Promise<unknown>>(
  params: PayableControllerFindManyParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof payableControllerFindMany>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getPayableControllerFindManyKey(params) : null);
  const swrFn = () => payableControllerFindMany(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type payableControllerUpdateResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getPayableControllerUpdateUrl = (id: string,) => {


  return `/v1/integrations/payable/${id}`
}

export const payableControllerUpdate = async (id: string,
    payableNoBaseModelDTO: PayableNoBaseModelDTO, options?: RequestInit): Promise<payableControllerUpdateResponse> => {
  
  const res = await fetch(getPayableControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      payableNoBaseModelDTO,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getPayableControllerUpdateMutationFetcher = (id: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: PayableNoBaseModelDTO }): Promise<payableControllerUpdateResponse> => {
    return payableControllerUpdate(id, arg, options);
  }
}
export const getPayableControllerUpdateMutationKey = (id: string,) => [`/v1/integrations/payable/${id}`] as const;

export type PayableControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof payableControllerUpdate>>>
export type PayableControllerUpdateMutationError = Promise<unknown>

export const usePayableControllerUpdate = <TError = Promise<unknown>>(
  id: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof payableControllerUpdate>>, TError, Key, PayableNoBaseModelDTO, Awaited<ReturnType<typeof payableControllerUpdate>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPayableControllerUpdateMutationKey(id);
  const swrFn = getPayableControllerUpdateMutationFetcher(id, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type payableControllerFindOneResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getPayableControllerFindOneUrl = (id: string,
    params?: PayableControllerFindOneParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `/v1/integrations/payable/${id}?${normalizedParams.toString()}` : `/v1/integrations/payable/${id}`
}

export const payableControllerFindOne = async (id: string,
    params?: PayableControllerFindOneParams, options?: RequestInit): Promise<payableControllerFindOneResponse> => {
  
  const res = await fetch(getPayableControllerFindOneUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getPayableControllerFindOneKey = (id: string,
    params?: PayableControllerFindOneParams,) => [`/v1/integrations/payable/${id}`, ...(params ? [params]: [])] as const;

export type PayableControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof payableControllerFindOne>>>
export type PayableControllerFindOneQueryError = Promise<unknown>

export const usePayableControllerFindOne = <TError = Promise<unknown>>(
  id: string,
    params?: PayableControllerFindOneParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof payableControllerFindOne>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(id)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getPayableControllerFindOneKey(id,params) : null);
  const swrFn = () => payableControllerFindOne(id,params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type payableControllerRemoveResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getPayableControllerRemoveUrl = (id: string,) => {


  return `/v1/integrations/payable/${id}`
}

export const payableControllerRemove = async (id: string, options?: RequestInit): Promise<payableControllerRemoveResponse> => {
  
  const res = await fetch(getPayableControllerRemoveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getPayableControllerRemoveMutationFetcher = (id: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<payableControllerRemoveResponse> => {
    return payableControllerRemove(id, options);
  }
}
export const getPayableControllerRemoveMutationKey = (id: string,) => [`/v1/integrations/payable/${id}`] as const;

export type PayableControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof payableControllerRemove>>>
export type PayableControllerRemoveMutationError = Promise<unknown>

export const usePayableControllerRemove = <TError = Promise<unknown>>(
  id: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof payableControllerRemove>>, TError, Key, Arguments, Awaited<ReturnType<typeof payableControllerRemove>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPayableControllerRemoveMutationKey(id);
  const swrFn = getPayableControllerRemoveMutationFetcher(id, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type payableControllerCreateManyResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getPayableControllerCreateManyUrl = () => {


  return `/v1/integrations/payable/batch`
}

export const payableControllerCreateMany = async (payableControllerCreateManyBody: PayableControllerCreateManyBody, options?: RequestInit): Promise<payableControllerCreateManyResponse> => {
    const formData = new FormData();
if(payableControllerCreateManyBody.file !== undefined) {
 formData.append('file', payableControllerCreateManyBody.file)
 }

  const res = await fetch(getPayableControllerCreateManyUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getPayableControllerCreateManyMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: PayableControllerCreateManyBody }): Promise<payableControllerCreateManyResponse> => {
    return payableControllerCreateMany(arg, options);
  }
}
export const getPayableControllerCreateManyMutationKey = () => [`/v1/integrations/payable/batch`] as const;

export type PayableControllerCreateManyMutationResult = NonNullable<Awaited<ReturnType<typeof payableControllerCreateMany>>>
export type PayableControllerCreateManyMutationError = Promise<unknown>

export const usePayableControllerCreateMany = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof payableControllerCreateMany>>, TError, Key, PayableControllerCreateManyBody, Awaited<ReturnType<typeof payableControllerCreateMany>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPayableControllerCreateManyMutationKey();
  const swrFn = getPayableControllerCreateManyMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type payableControllerUploadFileResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getPayableControllerUploadFileUrl = () => {


  return `/v1/integrations/payable/upload`
}

export const payableControllerUploadFile = async (payableControllerUploadFileBody: PayableControllerUploadFileBody, options?: RequestInit): Promise<payableControllerUploadFileResponse> => {
    const formData = new FormData();
if(payableControllerUploadFileBody.file !== undefined) {
 formData.append('file', payableControllerUploadFileBody.file)
 }

  const res = await fetch(getPayableControllerUploadFileUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getPayableControllerUploadFileMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: PayableControllerUploadFileBody }): Promise<payableControllerUploadFileResponse> => {
    return payableControllerUploadFile(arg, options);
  }
}
export const getPayableControllerUploadFileMutationKey = () => [`/v1/integrations/payable/upload`] as const;

export type PayableControllerUploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof payableControllerUploadFile>>>
export type PayableControllerUploadFileMutationError = Promise<unknown>

export const usePayableControllerUploadFile = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof payableControllerUploadFile>>, TError, Key, PayableControllerUploadFileBody, Awaited<ReturnType<typeof payableControllerUploadFile>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPayableControllerUploadFileMutationKey();
  const swrFn = getPayableControllerUploadFileMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type assignorControllerCreateResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getAssignorControllerCreateUrl = () => {


  return `/v1/integrations/assignor`
}

export const assignorControllerCreate = async (assignorNoBaseModelDTO: AssignorNoBaseModelDTO, options?: RequestInit): Promise<assignorControllerCreateResponse> => {
  
  const res = await fetch(getAssignorControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      assignorNoBaseModelDTO,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getAssignorControllerCreateMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: AssignorNoBaseModelDTO }): Promise<assignorControllerCreateResponse> => {
    return assignorControllerCreate(arg, options);
  }
}
export const getAssignorControllerCreateMutationKey = () => [`/v1/integrations/assignor`] as const;

export type AssignorControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof assignorControllerCreate>>>
export type AssignorControllerCreateMutationError = Promise<unknown>

export const useAssignorControllerCreate = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof assignorControllerCreate>>, TError, Key, AssignorNoBaseModelDTO, Awaited<ReturnType<typeof assignorControllerCreate>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getAssignorControllerCreateMutationKey();
  const swrFn = getAssignorControllerCreateMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type assignorControllerFindManyResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getAssignorControllerFindManyUrl = (params: AssignorControllerFindManyParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `/v1/integrations/assignor?${normalizedParams.toString()}` : `/v1/integrations/assignor`
}

export const assignorControllerFindMany = async (params: AssignorControllerFindManyParams, options?: RequestInit): Promise<assignorControllerFindManyResponse> => {
  
  const res = await fetch(getAssignorControllerFindManyUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getAssignorControllerFindManyKey = (params: AssignorControllerFindManyParams,) => [`/v1/integrations/assignor`, ...(params ? [params]: [])] as const;

export type AssignorControllerFindManyQueryResult = NonNullable<Awaited<ReturnType<typeof assignorControllerFindMany>>>
export type AssignorControllerFindManyQueryError = Promise<unknown>

export const useAssignorControllerFindMany = <TError = Promise<unknown>>(
  params: AssignorControllerFindManyParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof assignorControllerFindMany>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getAssignorControllerFindManyKey(params) : null);
  const swrFn = () => assignorControllerFindMany(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type assignorControllerUpdateResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getAssignorControllerUpdateUrl = (id: string,) => {


  return `/v1/integrations/assignor/${id}`
}

export const assignorControllerUpdate = async (id: string,
    assignorNoBaseModelDTO: AssignorNoBaseModelDTO, options?: RequestInit): Promise<assignorControllerUpdateResponse> => {
  
  const res = await fetch(getAssignorControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      assignorNoBaseModelDTO,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getAssignorControllerUpdateMutationFetcher = (id: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: AssignorNoBaseModelDTO }): Promise<assignorControllerUpdateResponse> => {
    return assignorControllerUpdate(id, arg, options);
  }
}
export const getAssignorControllerUpdateMutationKey = (id: string,) => [`/v1/integrations/assignor/${id}`] as const;

export type AssignorControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof assignorControllerUpdate>>>
export type AssignorControllerUpdateMutationError = Promise<unknown>

export const useAssignorControllerUpdate = <TError = Promise<unknown>>(
  id: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof assignorControllerUpdate>>, TError, Key, AssignorNoBaseModelDTO, Awaited<ReturnType<typeof assignorControllerUpdate>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getAssignorControllerUpdateMutationKey(id);
  const swrFn = getAssignorControllerUpdateMutationFetcher(id, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type assignorControllerFindOneResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getAssignorControllerFindOneUrl = (id: string,
    params?: AssignorControllerFindOneParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `/v1/integrations/assignor/${id}?${normalizedParams.toString()}` : `/v1/integrations/assignor/${id}`
}

export const assignorControllerFindOne = async (id: string,
    params?: AssignorControllerFindOneParams, options?: RequestInit): Promise<assignorControllerFindOneResponse> => {
  
  const res = await fetch(getAssignorControllerFindOneUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getAssignorControllerFindOneKey = (id: string,
    params?: AssignorControllerFindOneParams,) => [`/v1/integrations/assignor/${id}`, ...(params ? [params]: [])] as const;

export type AssignorControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof assignorControllerFindOne>>>
export type AssignorControllerFindOneQueryError = Promise<unknown>

export const useAssignorControllerFindOne = <TError = Promise<unknown>>(
  id: string,
    params?: AssignorControllerFindOneParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof assignorControllerFindOne>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(id)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getAssignorControllerFindOneKey(id,params) : null);
  const swrFn = () => assignorControllerFindOne(id,params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type assignorControllerRemoveResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getAssignorControllerRemoveUrl = (id: string,) => {


  return `/v1/integrations/assignor/${id}`
}

export const assignorControllerRemove = async (id: string, options?: RequestInit): Promise<assignorControllerRemoveResponse> => {
  
  const res = await fetch(getAssignorControllerRemoveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getAssignorControllerRemoveMutationFetcher = (id: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<assignorControllerRemoveResponse> => {
    return assignorControllerRemove(id, options);
  }
}
export const getAssignorControllerRemoveMutationKey = (id: string,) => [`/v1/integrations/assignor/${id}`] as const;

export type AssignorControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof assignorControllerRemove>>>
export type AssignorControllerRemoveMutationError = Promise<unknown>

export const useAssignorControllerRemove = <TError = Promise<unknown>>(
  id: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof assignorControllerRemove>>, TError, Key, Arguments, Awaited<ReturnType<typeof assignorControllerRemove>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getAssignorControllerRemoveMutationKey(id);
  const swrFn = getAssignorControllerRemoveMutationFetcher(id, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type userControllerCreateResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getUserControllerCreateUrl = () => {


  return `/v1/user`
}

export const userControllerCreate = async (userNoBaseModelDTO: UserNoBaseModelDTO, options?: RequestInit): Promise<userControllerCreateResponse> => {
  
  const res = await fetch(getUserControllerCreateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userNoBaseModelDTO,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getUserControllerCreateMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: UserNoBaseModelDTO }): Promise<userControllerCreateResponse> => {
    return userControllerCreate(arg, options);
  }
}
export const getUserControllerCreateMutationKey = () => [`/v1/user`] as const;

export type UserControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerCreate>>>
export type UserControllerCreateMutationError = Promise<unknown>

export const useUserControllerCreate = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof userControllerCreate>>, TError, Key, UserNoBaseModelDTO, Awaited<ReturnType<typeof userControllerCreate>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUserControllerCreateMutationKey();
  const swrFn = getUserControllerCreateMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type userControllerFindManyResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getUserControllerFindManyUrl = (params: UserControllerFindManyParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `/v1/user?${normalizedParams.toString()}` : `/v1/user`
}

export const userControllerFindMany = async (params: UserControllerFindManyParams, options?: RequestInit): Promise<userControllerFindManyResponse> => {
  
  const res = await fetch(getUserControllerFindManyUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getUserControllerFindManyKey = (params: UserControllerFindManyParams,) => [`/v1/user`, ...(params ? [params]: [])] as const;

export type UserControllerFindManyQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerFindMany>>>
export type UserControllerFindManyQueryError = Promise<unknown>

export const useUserControllerFindMany = <TError = Promise<unknown>>(
  params: UserControllerFindManyParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof userControllerFindMany>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getUserControllerFindManyKey(params) : null);
  const swrFn = () => userControllerFindMany(params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type userControllerUpdateResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getUserControllerUpdateUrl = (id: string,) => {


  return `/v1/user/${id}`
}

export const userControllerUpdate = async (id: string,
    userNoBaseModelDTO: UserNoBaseModelDTO, options?: RequestInit): Promise<userControllerUpdateResponse> => {
  
  const res = await fetch(getUserControllerUpdateUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userNoBaseModelDTO,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getUserControllerUpdateMutationFetcher = (id: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: UserNoBaseModelDTO }): Promise<userControllerUpdateResponse> => {
    return userControllerUpdate(id, arg, options);
  }
}
export const getUserControllerUpdateMutationKey = (id: string,) => [`/v1/user/${id}`] as const;

export type UserControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdate>>>
export type UserControllerUpdateMutationError = Promise<unknown>

export const useUserControllerUpdate = <TError = Promise<unknown>>(
  id: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof userControllerUpdate>>, TError, Key, UserNoBaseModelDTO, Awaited<ReturnType<typeof userControllerUpdate>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUserControllerUpdateMutationKey(id);
  const swrFn = getUserControllerUpdateMutationFetcher(id, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type userControllerFindOneResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getUserControllerFindOneUrl = (id: string,
    params?: UserControllerFindOneParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `/v1/user/${id}?${normalizedParams.toString()}` : `/v1/user/${id}`
}

export const userControllerFindOne = async (id: string,
    params?: UserControllerFindOneParams, options?: RequestInit): Promise<userControllerFindOneResponse> => {
  
  const res = await fetch(getUserControllerFindOneUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getUserControllerFindOneKey = (id: string,
    params?: UserControllerFindOneParams,) => [`/v1/user/${id}`, ...(params ? [params]: [])] as const;

export type UserControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerFindOne>>>
export type UserControllerFindOneQueryError = Promise<unknown>

export const useUserControllerFindOne = <TError = Promise<unknown>>(
  id: string,
    params?: UserControllerFindOneParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof userControllerFindOne>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(id)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getUserControllerFindOneKey(id,params) : null);
  const swrFn = () => userControllerFindOne(id,params, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type userControllerRemoveResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getUserControllerRemoveUrl = (id: string,) => {


  return `/v1/user/${id}`
}

export const userControllerRemove = async (id: string, options?: RequestInit): Promise<userControllerRemoveResponse> => {
  
  const res = await fetch(getUserControllerRemoveUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getUserControllerRemoveMutationFetcher = (id: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<userControllerRemoveResponse> => {
    return userControllerRemove(id, options);
  }
}
export const getUserControllerRemoveMutationKey = (id: string,) => [`/v1/user/${id}`] as const;

export type UserControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerRemove>>>
export type UserControllerRemoveMutationError = Promise<unknown>

export const useUserControllerRemove = <TError = Promise<unknown>>(
  id: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof userControllerRemove>>, TError, Key, Arguments, Awaited<ReturnType<typeof userControllerRemove>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUserControllerRemoveMutationKey(id);
  const swrFn = getUserControllerRemoveMutationFetcher(id, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type emailControllerSendMailerResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getEmailControllerSendMailerUrl = () => {


  return `/v1/email`
}

export const emailControllerSendMailer = async (emailDTO: EmailDTO, options?: RequestInit): Promise<emailControllerSendMailerResponse> => {
  
  const res = await fetch(getEmailControllerSendMailerUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      emailDTO,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getEmailControllerSendMailerMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: EmailDTO }): Promise<emailControllerSendMailerResponse> => {
    return emailControllerSendMailer(arg, options);
  }
}
export const getEmailControllerSendMailerMutationKey = () => [`/v1/email`] as const;

export type EmailControllerSendMailerMutationResult = NonNullable<Awaited<ReturnType<typeof emailControllerSendMailer>>>
export type EmailControllerSendMailerMutationError = Promise<unknown>

export const useEmailControllerSendMailer = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof emailControllerSendMailer>>, TError, Key, EmailDTO, Awaited<ReturnType<typeof emailControllerSendMailer>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getEmailControllerSendMailerMutationKey();
  const swrFn = getEmailControllerSendMailerMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type authControllerSignInResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getAuthControllerSignInUrl = () => {


  return `/v1/integrations/auth`
}

export const authControllerSignIn = async (userNoBaseModelDTO: UserNoBaseModelDTO, options?: RequestInit): Promise<authControllerSignInResponse> => {
  
  const res = await fetch(getAuthControllerSignInUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userNoBaseModelDTO,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getAuthControllerSignInMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: UserNoBaseModelDTO }): Promise<authControllerSignInResponse> => {
    return authControllerSignIn(arg, options);
  }
}
export const getAuthControllerSignInMutationKey = () => [`/v1/integrations/auth`] as const;

export type AuthControllerSignInMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerSignIn>>>
export type AuthControllerSignInMutationError = Promise<unknown>

export const useAuthControllerSignIn = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof authControllerSignIn>>, TError, Key, UserNoBaseModelDTO, Awaited<ReturnType<typeof authControllerSignIn>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getAuthControllerSignInMutationKey();
  const swrFn = getAuthControllerSignInMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

export type authControllerGetProfileResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getAuthControllerGetProfileUrl = () => {


  return `/v1/integrations/auth/user`
}

export const authControllerGetProfile = async ( options?: RequestInit): Promise<authControllerGetProfileResponse> => {
  
  const res = await fetch(getAuthControllerGetProfileUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getAuthControllerGetProfileKey = () => [`/v1/integrations/auth/user`] as const;

export type AuthControllerGetProfileQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerGetProfile>>>
export type AuthControllerGetProfileQueryError = Promise<unknown>

export const useAuthControllerGetProfile = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof authControllerGetProfile>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getAuthControllerGetProfileKey() : null);
  const swrFn = () => authControllerGetProfile(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

